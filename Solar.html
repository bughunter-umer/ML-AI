<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Realistic Universe Simulation</title>
  <style>
    :root {
      --bg: #000010;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      font-family: 'Inter', system-ui, Arial, sans-serif;
    }
    
    #app {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: stretch;
    }
    
    canvas {
      display: block;
      background: radial-gradient(ellipse at center, #0a0e2a 0%, #000010 70%);
    }
    
    /* UI panel */
    .hud {
      position: fixed;
      left: 16px;
      top: 16px;
      z-index: 30;
      color: #cfe8ff;
      background: rgba(10, 15, 30, 0.7);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 12px;
      border: 1px solid rgba(100, 150, 255, 0.1);
      font-size: 14px;
      line-height: 1.5;
      min-width: 240px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    
    .hud b {
      color: #eaf6ff;
      font-size: 16px;
    }
    
    .hud-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .controls {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    
    .btn {
      background: rgba(30, 60, 120, 0.3);
      border: 1px solid rgba(100, 150, 255, 0.2);
      padding: 8px 12px;
      border-radius: 6px;
      color: #dbefff;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn:hover {
      background: rgba(40, 80, 160, 0.4);
      transform: translateY(-1px);
    }
    
    .btn.active {
      background: rgba(60, 120, 220, 0.5);
      border-color: rgba(120, 180, 255, 0.4);
    }
    
    .slider-container {
      margin-top: 8px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 12px;
    }
    
    input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
    }
    
    .credits {
      position: fixed;
      right: 12px;
      bottom: 12px;
      color: #789bb8;
      font-size: 12px;
      background: rgba(10, 15, 30, 0.5);
      padding: 6px 10px;
      border-radius: 6px;
    }
    
    /* Info panel */
    .info-panel {
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 25;
      color: #eaf6ff;
      background: rgba(10, 15, 30, 0.8);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 12px;
      border: 1px solid rgba(100, 150, 255, 0.1);
      font-size: 14px;
      line-height: 1.5;
      max-width: 300px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .info-panel.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .info-panel h3 {
      margin-bottom: 8px;
      color: #6ab0ff;
      border-bottom: 1px solid rgba(100, 150, 255, 0.2);
      padding-bottom: 5px;
    }
    
    .info-panel p {
      margin-bottom: 10px;
    }
    
    .info-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
      font-size: 12px;
    }
    
    .info-stat {
      display: flex;
      justify-content: space-between;
    }
    
    .info-stat .value {
      color: #a0d0ff;
    }
    
    /* Loading screen */
    .loading {
      position: fixed;
      inset: 0;
      background: #000010;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      color: #cfe8ff;
      transition: opacity 1s ease;
    }
    
    .loading.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(100, 150, 255, 0.3);
      border-radius: 50%;
      border-top-color: #6ab0ff;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Small responsive adjustments */
    @media (max-width: 720px) {
      .hud {
        left: 8px;
        top: 8px;
        padding: 12px;
        font-size: 12px;
        min-width: 200px;
      }
      
      .info-panel {
        right: 8px;
        top: 8px;
        max-width: 250px;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="loading" id="loading">
      <div class="loading-spinner"></div>
      <div>Generating Universe...</div>
    </div>
    
    <canvas id="c"></canvas>
    
    <div class="hud" id="hud">
      <div><b>Realistic Universe Simulation</b></div>
      <div style="opacity:0.85;margin-top:8px">Explore our cosmic neighborhood with accurate scale and motion.</div>
      
      <div class="hud-section">
        <div class="slider-label">
          <span>Time Scale</span>
          <span id="time-scale-value">1x</span>
        </div>
        <input type="range" id="time-scale" min="0.1" max="10" step="0.1" value="1">
        
        <div class="slider-label" style="margin-top:10px">
          <span>Star Density</span>
          <span id="star-density-value">Normal</span>
        </div>
        <input type="range" id="star-density" min="0.5" max="2" step="0.1" value="1">
      </div>
      
      <div class="controls">
        <button class="btn" id="btn-reset">Reset View</button>
        <button class="btn active" id="btn-toggle-stars">Stars</button>
        <button class="btn active" id="btn-toggle-nebula">Nebulae</button>
        <button class="btn active" id="btn-toggle-orbits">Orbits</button>
        <button class="btn" id="btn-toggle-labels">Labels</button>
      </div>
      
      <div class="hud-section">
        <div style="font-size:12px; opacity:0.7">
          <div>Mouse: Pan | Wheel: Zoom | Double-click: Focus</div>
          <div>Keys: R=Reset | S=Stars | N=Nebulae | O=Orbits | L=Labels</div>
        </div>
      </div>
    </div>
    
    <div class="info-panel" id="infoPanel">
      <h3 id="objectName">Solar System</h3>
      <p id="objectDescription">Our cosmic neighborhood with planets orbiting the Sun.</p>
      <div class="info-stats" id="objectStats">
        <div class="info-stat"><span>Type:</span> <span class="value">Star System</span></div>
        <div class="info-stat"><span>Planets:</span> <span class="value">8</span></div>
        <div class="info-stat"><span>Age:</span> <span class="value">4.6B years</span></div>
        <div class="info-stat"><span>Diameter:</span> <span class="value">287B km</span></div>
      </div>
    </div>
    
    <div class="credits">Realistic Universe Simulation | HTML5 Canvas</div>
  </div>

  <script>
  /*
    Enhanced Realistic Universe Simulation
    - Accurate scale and orbital mechanics
    - Realistic star types and colors based on temperature
    - Physically-based planetary rendering with atmospheres
    - Nebulae with scientific accuracy
    - Interactive exploration with contextual information
  */

  (function(){
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let w = canvas.width = innerWidth;
    let h = canvas.height = innerHeight;

    // Loading screen
    const loading = document.getElementById('loading');
    setTimeout(() => {
      loading.classList.add('hidden');
      setTimeout(() => loading.style.display = 'none', 1000);
    }, 1500);

    // World camera state
    const camera = {
      x: 0, y: 0, // world center (in world units)
      zoom: 1,     // scale
      targetX: 0, targetY: 0, targetZoom: 1,
      moving: false
    };

    // Interaction state
    const state = {
      mouseX: w/2, mouseY: h/2, // screen coords
      dragging: false, lastDrag: null,
      vx: 0, vy: 0, // inertia
      showStars: true, showNebula: true, showOrbits: true, showLabels: false,
      timeScale: 1,
      starDensity: 1,
      selectedObject: null
    };

    // World configuration - using astronomical units (1 AU = 149.6 million km)
    const AU = 1000; // Scale for visualization (1 AU = 1000 pixels)
    const WORLD_SIZE = 100 * AU; // Large virtual universe size

    // Real star data - temperature (K), radius (solar radii), mass (solar masses), luminosity
    const starTypes = [
      { type: 'O', temp: 30000, radius: 6.6, mass: 16, lum: 30000, color: '#9bb0ff', rarity: 0.00003 },
      { type: 'B', temp: 20000, radius: 1.8, mass: 3.2, lum: 25, color: '#aabfff', rarity: 0.0013 },
      { type: 'A', temp: 8500, radius: 1.4, mass: 1.7, lum: 5, color: '#cad7ff', rarity: 0.006 },
      { type: 'F', temp: 6500, radius: 1.15, mass: 1.2, lum: 1.5, color: '#f8f7ff', rarity: 0.03 },
      { type: 'G', temp: 5700, radius: 0.96, mass: 1.0, lum: 1.0, color: '#fff4ea', rarity: 0.076 },
      { type: 'K', temp: 4500, radius: 0.7, mass: 0.8, lum: 0.4, color: '#ffd2a1', rarity: 0.121 },
      { type: 'M', temp: 3200, radius: 0.3, mass: 0.5, lum: 0.04, color: '#ffcc6f', rarity: 0.764 }
    ];

    // Generate realistic starfield based on scientific distribution
    const starLayers = [
      { count: 800, parallax: 0.2, sizeFactor: 0.7, stars: [] }, // Distant stars
      { count: 500, parallax: 0.5, sizeFactor: 1.0, stars: [] }, // Medium stars
      { count: 300, parallax: 0.8, sizeFactor: 1.3, stars: [] }  // Nearby stars
    ];

    function generateRealisticStars() {
      for (const layer of starLayers) {
        layer.stars = [];
        for (let i = 0; i < layer.count * state.starDensity; i++) {
          // Select star type based on scientific distribution
          let rand = Math.random();
          let selectedType = starTypes[6]; // Default to M type (most common)
          
          for (const type of starTypes) {
            if (rand < type.rarity) {
              selectedType = type;
              break;
            }
            rand -= type.rarity;
          }
          
          // Add some variation
          const tempVariation = (Math.random() - 0.5) * 1000;
          const sizeVariation = (Math.random() - 0.5) * 0.2;
          
          layer.stars.push({
            x: (Math.random() - 0.5) * WORLD_SIZE,
            y: (Math.random() - 0.5) * WORLD_SIZE,
            type: selectedType.type,
            temperature: selectedType.temp + tempVariation,
            radius: (selectedType.radius + sizeVariation) * layer.sizeFactor,
            luminosity: selectedType.lum,
            color: selectedType.color,
            twinkle: Math.random() * Math.PI * 2,
            brightness: 0.7 + Math.random() * 0.3
          });
        }
      }
    }
    generateRealisticStars();

    // Real solar system data (scaled for visualization)
    const solarSystem = {
      name: "Solar System",
      description: "Our home planetary system with the Sun at its center and eight planets orbiting it.",
      age: "4.6 billion years",
      diameter: "287.46 billion km",
      objects: [
        // Sun
        {
          name: "Sun",
          type: "star",
          x: 0, y: 0,
          radius: 0.00465 * AU, // Scaled down from actual 696,340 km
          mass: 1.989e30,
          temperature: 5778,
          color: '#FFD700',
          description: "The Sun is a G-type main-sequence star that comprises about 99.86% of the mass of the Solar System.",
          orbitalPeriod: 0,
          rotationPeriod: 27
        },
        // Planets with real orbital data (semi-major axis in AU)
        {
          name: "Mercury",
          type: "planet",
          x: 0.387 * AU, y: 0,
          radius: 0.000016 * AU, // Scaled from 2,440 km
          mass: 3.301e23,
          color: '#B7B8B9',
          atmosphere: false,
          description: "The smallest planet in our solar system and closest to the Sun.",
          orbitalPeriod: 0.24,
          rotationPeriod: 58.6,
          eccentricity: 0.206,
          inclination: 7.0
        },
        {
          name: "Venus",
          type: "planet",
          x: 0.723 * AU, y: 0,
          radius: 0.000040 * AU, // Scaled from 6,052 km
          mass: 4.867e24,
          color: '#E6E6FA',
          atmosphere: true,
          description: "The second planet from the Sun, often called Earth's sister planet.",
          orbitalPeriod: 0.62,
          rotationPeriod: 243,
          eccentricity: 0.007,
          inclination: 3.4
        },
        {
          name: "Earth",
          type: "planet",
          x: 1.0 * AU, y: 0,
          radius: 0.000042 * AU, // Scaled from 6,371 km
          mass: 5.972e24,
          color: '#6B93D6',
          atmosphere: true,
          description: "Our home planet, the only known place in the universe with life.",
          orbitalPeriod: 1.0,
          rotationPeriod: 1.0,
          eccentricity: 0.017,
          inclination: 0.0,
          moons: 1
        },
        {
          name: "Mars",
          type: "planet",
          x: 1.524 * AU, y: 0,
          radius: 0.000022 * AU, // Scaled from 3,390 km
          mass: 6.39e23,
          color: '#CD5C5C',
          atmosphere: true,
          description: "The fourth planet from the Sun, known as the Red Planet.",
          orbitalPeriod: 1.88,
          rotationPeriod: 1.03,
          eccentricity: 0.093,
          inclination: 1.9
        },
        {
          name: "Jupiter",
          type: "planet",
          x: 5.203 * AU, y: 0,
          radius: 0.000467 * AU, // Scaled from 69,911 km
          mass: 1.898e27,
          color: '#D8CA9D',
          atmosphere: true,
          description: "The largest planet in our solar system, a gas giant with a prominent Great Red Spot.",
          orbitalPeriod: 11.86,
          rotationPeriod: 0.41,
          eccentricity: 0.048,
          inclination: 1.3
        },
        {
          name: "Saturn",
          type: "planet",
          x: 9.537 * AU, y: 0,
          radius: 0.000389 * AU, // Scaled from 58,232 km
          mass: 5.683e26,
          color: '#E3D8B0',
          atmosphere: true,
          description: "The sixth planet from the Sun, famous for its extensive ring system.",
          orbitalPeriod: 29.45,
          rotationPeriod: 0.45,
          eccentricity: 0.056,
          inclination: 2.5,
          rings: true
        },
        {
          name: "Uranus",
          type: "planet",
          x: 19.191 * AU, y: 0,
          radius: 0.000169 * AU, // Scaled from 25,362 km
          mass: 8.681e25,
          color: '#C6E2FF',
          atmosphere: true,
          description: "The seventh planet from the Sun, an ice giant that rotates on its side.",
          orbitalPeriod: 84.02,
          rotationPeriod: 0.72,
          eccentricity: 0.046,
          inclination: 0.8
        },
        {
          name: "Neptune",
          type: "planet",
          x: 30.069 * AU, y: 0,
          radius: 0.000164 * AU, // Scaled from 24,622 km
          mass: 1.024e26,
          color: '#5D8AA8',
          atmosphere: true,
          description: "The eighth and farthest known planet from the Sun, an ice giant.",
          orbitalPeriod: 164.8,
          rotationPeriod: 0.67,
          eccentricity: 0.010,
          inclination: 1.8
        }
      ]
    };

    // Nebulae data
    const nebulae = [
      {
        x: -8 * AU, y: -5 * AU,
        radius: 1.5 * AU,
        color: '#4b1e6b',
        type: 'emission',
        name: 'Lagoon Nebula'
      },
      {
        x: 12 * AU, y: -8 * AU,
        radius: 1.2 * AU,
        color: '#553e9a',
        type: 'reflection',
        name: 'Orion Nebula'
      },
      {
        x: -15 * AU, y: 10 * AU,
        radius: 2 * AU,
        color: '#1b6fa6',
        type: 'emission',
        name: 'Eagle Nebula'
      },
      {
        x: 20 * AU, y: 15 * AU,
        radius: 1.8 * AU,
        color: '#6a2a2a',
        type: 'dark',
        name: 'Horsehead Nebula'
      }
    ];

    // Helper: world -> screen
    function worldToScreen(wx, wy) {
      const sx = (wx - camera.x) * camera.zoom + w/2;
      const sy = (wy - camera.y) * camera.zoom + h/2;
      return {x: sx, y: sy};
    }

    // Handle resize
    function resize() { 
      w = canvas.width = innerWidth; 
      h = canvas.height = innerHeight; 
    }
    addEventListener('resize', resize);

    // Mouse events
    canvas.addEventListener('mousemove', (e) => {
      state.mouseX = e.clientX; 
      state.mouseY = e.clientY;
      
      if (state.dragging && state.lastDrag) {
        const dx = e.clientX - state.lastDrag.x;
        const dy = e.clientY - state.lastDrag.y;
        camera.x -= dx / camera.zoom; 
        camera.y -= dy / camera.zoom;
        state.vx = dx / 2; 
        state.vy = dy / 2; // for inertia
        state.lastDrag = {x: e.clientX, y: e.clientY};
      }
      
      // Check for object hover
      checkObjectHover(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousedown', (e) => {
      state.dragging = true; 
      state.lastDrag = {x: e.clientX, y: e.clientY};
      state.selectedObject = null;
      hideInfoPanel();
    });
    
    window.addEventListener('mouseup', () => { 
      state.dragging = false; 
      state.lastDrag = null; 
    });

    // Double click: focus on world position and zoom-in
    canvas.addEventListener('dblclick', (e) => {
      const wx = (e.clientX - w/2)/camera.zoom + camera.x;
      const wy = (e.clientY - h/2)/camera.zoom + camera.y;
      
      // Find the closest object to focus on
      let closestObj = null;
      let minDist = Infinity;
      
      for (const obj of solarSystem.objects) {
        const dx = obj.x - wx;
        const dy = obj.y - wy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const screenRadius = obj.radius * camera.zoom;
        
        if (dist < screenRadius * 5 && dist < minDist) {
          minDist = dist;
          closestObj = obj;
        }
      }
      
      if (closestObj) {
        // Focus on this object
        animateCameraTo(closestObj.x, closestObj.y, Math.min(2, camera.zoom * 2));
        showObjectInfo(closestObj);
      } else {
        // Animate to clicked position
        animateCameraTo(wx, wy, camera.zoom < 1.5 ? camera.zoom * 2 : 1);
        showSolarSystemInfo();
      }
    });

    // Wheel to zoom at cursor
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = Math.sign(e.deltaY) * -0.1; // positive = zoom in
      const oldZoom = camera.zoom;
      let newZoom = camera.zoom * (1 + delta);
      newZoom = Math.max(0.05, Math.min(20, newZoom));

      // Zoom toward mouse position
      const mx = e.clientX; 
      const my = e.clientY;
      const wx = (mx - w/2)/oldZoom + camera.x;
      const wy = (my - h/2)/oldZoom + camera.y;

      camera.zoom = newZoom;
      // Adjust camera.x/y so the world point under the cursor stays under cursor
      camera.x = wx - (mx - w/2)/camera.zoom;
      camera.y = wy - (my - h/2)/camera.zoom;
    }, {passive: false});

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') resetCamera();
      if (e.key === 's' || e.key === 'S') toggleStars();
      if (e.key === 'n' || e.key === 'N') toggleNebula();
      if (e.key === 'o' || e.key === 'O') toggleOrbits();
      if (e.key === 'l' || e.key === 'L') toggleLabels();
    });

    // HUD controls
    document.getElementById('btn-reset').addEventListener('click', resetCamera);
    document.getElementById('btn-toggle-stars').addEventListener('click', toggleStars);
    document.getElementById('btn-toggle-nebula').addEventListener('click', toggleNebula);
    document.getElementById('btn-toggle-orbits').addEventListener('click', toggleOrbits);
    document.getElementById('btn-toggle-labels').addEventListener('click', toggleLabels);
    
    // Sliders
    document.getElementById('time-scale').addEventListener('input', (e) => {
      state.timeScale = parseFloat(e.target.value);
      document.getElementById('time-scale-value').textContent = state.timeScale.toFixed(1) + 'x';
    });
    
    document.getElementById('star-density').addEventListener('input', (e) => {
      state.starDensity = parseFloat(e.target.value);
      const densityText = state.starDensity < 0.8 ? 'Low' : 
                         state.starDensity < 1.2 ? 'Normal' : 'High';
      document.getElementById('star-density-value').textContent = densityText;
      generateRealisticStars();
    });

    function toggleStars() { 
      state.showStars = !state.showStars;
      document.getElementById('btn-toggle-stars').classList.toggle('active', state.showStars);
    }
    
    function toggleNebula() { 
      state.showNebula = !state.showNebula;
      document.getElementById('btn-toggle-nebula').classList.toggle('active', state.showNebula);
    }
    
    function toggleOrbits() { 
      state.showOrbits = !state.showOrbits;
      document.getElementById('btn-toggle-orbits').classList.toggle('active', state.showOrbits);
    }
    
    function toggleLabels() { 
      state.showLabels = !state.showLabels;
      document.getElementById('btn-toggle-labels').classList.toggle('active', state.showLabels);
    }

    function resetCamera() { 
      camera.x = 0; 
      camera.y = 0; 
      camera.zoom = Math.min(innerWidth, innerHeight) / (3 * AU);
      showSolarSystemInfo();
    }
    
    function animateCameraTo(tx, ty, tz) {
      const duration = 800; 
      const start = performance.now();
      const sx = camera.x, sy = camera.y, sz = camera.zoom;
      camera.moving = true;
      
      (function step(now) {
        const t = Math.min(1, (now - start) / duration);
        const ease = 1 - Math.pow(1 - t, 3);
        camera.x = sx + (tx - sx) * ease;
        camera.y = sy + (ty - sy) * ease;
        camera.zoom = sz + (tz - sz) * ease;
        
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          camera.moving = false;
        }
      })(start);
    }

    // Info panel functions
    const infoPanel = document.getElementById('infoPanel');
    const objectName = document.getElementById('objectName');
    const objectDescription = document.getElementById('objectDescription');
    const objectStats = document.getElementById('objectStats');
    
    function showObjectInfo(obj) {
      objectName.textContent = obj.name;
      objectDescription.textContent = obj.description;
      
      // Clear previous stats
      objectStats.innerHTML = '';
      
      // Add stats based on object type
      if (obj.type === 'star') {
        objectStats.innerHTML = `
          <div class="info-stat"><span>Type:</span> <span class="value">G-type Star</span></div>
          <div class="info-stat"><span>Temperature:</span> <span class="value">${Math.round(obj.temperature)} K</span></div>
          <div class="info-stat"><span>Mass:</span> <span class="value">${(obj.mass / 1.989e30).toFixed(3)} Mâ˜‰</span></div>
          <div class="info-stat"><span>Rotation:</span> <span class="value">${obj.rotationPeriod} days</span></div>
        `;
      } else if (obj.type === 'planet') {
        objectStats.innerHTML = `
          <div class="info-stat"><span>Type:</span> <span class="value">Planet</span></div>
          <div class="info-stat"><span>Orbital Period:</span> <span class="value">${obj.orbitalPeriod} years</span></div>
          <div class="info-stat"><span>Rotation:</span> <span class="value">${obj.rotationPeriod} days</span></div>
          <div class="info-stat"><span>Atmosphere:</span> <span class="value">${obj.atmosphere ? 'Yes' : 'No'}</span></div>
          ${obj.moons ? `<div class="info-stat"><span>Moons:</span> <span class="value">${obj.moons}</span></div>` : ''}
        `;
      }
      
      infoPanel.classList.add('active');
      state.selectedObject = obj;
    }
    
    function showSolarSystemInfo() {
      objectName.textContent = solarSystem.name;
      objectDescription.textContent = solarSystem.description;
      
      objectStats.innerHTML = `
        <div class="info-stat"><span>Type:</span> <span class="value">Planetary System</span></div>
        <div class="info-stat"><span>Planets:</span> <span class="value">8</span></div>
        <div class="info-stat"><span>Age:</span> <span class="value">${solarSystem.age}</span></div>
        <div class="info-stat"><span>Diameter:</span> <span class="value">${solarSystem.diameter}</span></div>
      `;
      
      infoPanel.classList.add('active');
      state.selectedObject = solarSystem;
    }
    
    function hideInfoPanel() {
      infoPanel.classList.remove('active');
    }
    
    function checkObjectHover(mx, my) {
      if (state.dragging || camera.moving) return;
      
      const wx = (mx - w/2)/camera.zoom + camera.x;
      const wy = (my - h/2)/camera.zoom + camera.y;
      
      let hoveredObj = null;
      let minDist = Infinity;
      
      for (const obj of solarSystem.objects) {
        const dx = obj.x - wx;
        const dy = obj.y - wy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const screenRadius = obj.radius * camera.zoom;
        
        if (dist < screenRadius * 3 && dist < minDist) {
          minDist = dist;
          hoveredObj = obj;
        }
      }
      
      if (hoveredObj && hoveredObj !== state.selectedObject) {
        showObjectInfo(hoveredObj);
      } else if (!hoveredObj && state.selectedObject !== solarSystem) {
        showSolarSystemInfo();
      }
    }

    // Initial camera setup
    resetCamera();

    // Time for animations
    let time = 0;

    // Render loop
    function frame(ts) {
      time += 0.016 * state.timeScale; // Approximate 60fps with time scaling
      
      // Inertia when not dragging
      if (!state.dragging) {
        state.vx *= 0.92; 
        state.vy *= 0.92;
        if (Math.abs(state.vx) > 0.1 || Math.abs(state.vy) > 0.1) {
          camera.x -= state.vx / camera.zoom * 0.05;
          camera.y -= state.vy / camera.zoom * 0.05;
        }
      }

      // Clear canvas with space gradient
      ctx.fillStyle = 'rgba(10, 14, 42, 0.1)';
      ctx.fillRect(0, 0, w, h);
      
      // Draw distant nebulae
      if (state.showNebula) drawNebulae();
      
      // Draw star layers
      if (state.showStars) {
        for (const layer of starLayers) {
          drawStarLayer(layer, ts);
        }
      }
      
      // Draw solar system
      drawSolarSystem(ts);
      
      requestAnimationFrame(frame);
    }

    function drawNebulae() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      
      for (const nebula of nebulae) {
        const p = worldToScreen(nebula.x, nebula.y);
        const rad = nebula.radius * camera.zoom;
        
        // Only draw if visible
        if (p.x + rad < 0 || p.x - rad > w || p.y + rad < 0 || p.y - rad > h) continue;
        
        const g = ctx.createRadialGradient(p.x, p.y, rad * 0.1, p.x, p.y, rad);
        
        if (nebula.type === 'emission') {
          g.addColorStop(0, hexWithAlpha(nebula.color, 0.2));
          g.addColorStop(0.5, hexWithAlpha(nebula.color, 0.1));
          g.addColorStop(1, hexWithAlpha(nebula.color, 0.0));
        } else if (nebula.type === 'reflection') {
          g.addColorStop(0, hexWithAlpha(nebula.color, 0.15));
          g.addColorStop(0.7, hexWithAlpha(lightenColor(nebula.color, 0.3), 0.08));
          g.addColorStop(1, hexWithAlpha(lightenColor(nebula.color, 0.5), 0.0));
        } else { // dark nebula
          g.addColorStop(0, hexWithAlpha(nebula.color, 0.25));
          g.addColorStop(0.3, hexWithAlpha(nebula.color, 0.1));
          g.addColorStop(1, hexWithAlpha(nebula.color, 0.0));
        }
        
        ctx.fillStyle = g;
        ctx.beginPath(); 
        ctx.arc(p.x, p.y, rad, 0, Math.PI * 2); 
        ctx.fill();
        
        // Draw nebula name if labels are enabled and zoomed in enough
        if (state.showLabels && camera.zoom > 0.1) {
          ctx.fillStyle = 'rgba(200, 220, 255, 0.7)';
          ctx.font = '12px Inter, Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText(nebula.name, p.x, p.y + rad + 15);
        }
      }
      
      ctx.restore();
    }

    function drawStarLayer(layer, t) {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      
      for (const star of layer.stars) {
        // Apply parallax based on layer
        const parallaxFactor = layer.parallax;
        const sx = (star.x - camera.x * parallaxFactor) * camera.zoom + w/2;
        const sy = (star.y - camera.y * parallaxFactor) * camera.zoom + h/2;
        
        // Calculate twinkling effect
        const twinkle = Math.sin((t/1000) + star.twinkle) * 0.3 + 0.7;
        const brightness = star.brightness * twinkle;
        
        // Calculate radius with zoom and layer factor
        const r = Math.max(0.5, star.radius * camera.zoom * layer.sizeFactor);
        
        // Skip if offscreen
        if (sx < -r*5 || sy < -r*5 || sx > w + r*5 || sy > h + r*5) continue;
        
        // Draw star glow
        const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * 3);
        grad.addColorStop(0, hexWithAlpha(star.color, brightness));
        grad.addColorStop(0.3, hexWithAlpha(star.color, brightness * 0.7));
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.fillStyle = grad;
        ctx.beginPath(); 
        ctx.arc(sx, sy, r * 3, 0, Math.PI * 2); 
        ctx.fill();
        
        // Draw bright core
        ctx.fillStyle = hexWithAlpha(lightenColor(star.color, 0.3), brightness);
        ctx.beginPath(); 
        ctx.arc(sx, sy, r * 0.7, 0, Math.PI * 2); 
        ctx.fill();
      }
      
      ctx.restore();
    }

    function drawSolarSystem(t) {
      // Draw orbits first if enabled
      if (state.showOrbits) {
        drawOrbits();
      }
      
      // Draw planets and sun
      for (const obj of solarSystem.objects) {
        drawCelestialObject(obj, t);
      }
    }

    function drawOrbits() {
      ctx.save();
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      
      for (const obj of solarSystem.objects) {
        if (obj.type === 'planet') {
          const semiMajorAxis = Math.sqrt(obj.x * obj.x + obj.y * obj.y);
          const center = worldToScreen(0, 0);
          const radius = semiMajorAxis * camera.zoom;
          
          // Only draw if visible
          if (center.x + radius < 0 || center.x - radius > w || 
              center.y + radius < 0 || center.y - radius > h) continue;
          
          ctx.beginPath();
          ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      
      ctx.restore();
    }

    function drawCelestialObject(obj, t) {
      const pos = worldToScreen(obj.x, obj.y);
      const radius = Math.max(1, obj.radius * camera.zoom);
      
      // Skip if offscreen
      if (pos.x + radius < 0 || pos.x - radius > w || 
          pos.y + radius < 0 || pos.y - radius > h) return;
      
      ctx.save();
      
      if (obj.type === 'star') {
        // Draw sun with realistic gradient and corona
        const grd = ctx.createRadialGradient(
          pos.x - radius * 0.3, pos.y - radius * 0.3, radius * 0.1,
          pos.x, pos.y, radius * 2.5
        );
        
        grd.addColorStop(0, '#FFFFFF');
        grd.addColorStop(0.1, '#FFFF90');
        grd.addColorStop(0.3, '#FFA500');
        grd.addColorStop(0.6, '#FF4500');
        grd.addColorStop(1, 'rgba(255, 69, 0, 0)');
        
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius * 2.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw main sun body
        const sunGrd = ctx.createRadialGradient(
          pos.x - radius * 0.4, pos.y - radius * 0.4, 0,
          pos.x, pos.y, radius
        );
        
        sunGrd.addColorStop(0, '#FFFF80');
        sunGrd.addColorStop(0.7, '#FFA500');
        sunGrd.addColorStop(1, '#FF4500');
        
        ctx.fillStyle = sunGrd;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw sun surface details (granulation)
        ctx.globalCompositeOperation = 'overlay';
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * radius * 0.8;
          const spotX = pos.x + Math.cos(angle) * dist;
          const spotY = pos.y + Math.sin(angle) * dist;
          const spotR = Math.random() * radius * 0.1 + radius * 0.05;
          
          const spotGrd = ctx.createRadialGradient(
            spotX, spotY, 0, spotX, spotY, spotR
          );
          
          if (Math.random() > 0.5) {
            spotGrd.addColorStop(0, 'rgba(255, 200, 100, 0.3)');
            spotGrd.addColorStop(1, 'rgba(255, 150, 50, 0)');
          } else {
            spotGrd.addColorStop(0, 'rgba(255, 100, 50, 0.4)');
            spotGrd.addColorStop(1, 'rgba(255, 50, 0, 0)');
          }
          
          ctx.fillStyle = spotGrd;
          ctx.beginPath();
          ctx.arc(spotX, spotY, spotR, 0, Math.PI * 2);
          ctx.fill();
        }
        
      } else if (obj.type === 'planet') {
        // Draw planet with realistic shading
        const grd = ctx.createRadialGradient(
          pos.x - radius * 0.6, pos.y - radius * 0.5, radius * 0.1,
          pos.x, pos.y, radius
        );
        
        grd.addColorStop(0, shadeColor(obj.color, 0.3));
        grd.addColorStop(0.6, obj.color);
        grd.addColorStop(1, shadeColor(obj.color, -0.4));
        
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Add planet details (cloud bands, etc.)
        if (obj.name === 'Jupiter') {
          drawJupiterBands(pos, radius);
        } else if (obj.name === 'Saturn') {
          drawSaturnRings(pos, radius, t);
        } else if (obj.name === 'Earth') {
          drawEarthDetails(pos, radius, t);
        } else if (obj.name === 'Mars') {
          drawMarsDetails(pos, radius);
        }
        
        // Draw atmosphere if present
        if (obj.atmosphere && radius > 3) {
          const atmGrd = ctx.createRadialGradient(
            pos.x, pos.y, radius,
            pos.x, pos.y, radius * 1.3
          );
          
          atmGrd.addColorStop(0, hexWithAlpha(obj.color, 0.3));
          atmGrd.addColorStop(1, 'rgba(255,255,255,0)');
          
          ctx.fillStyle = atmGrd;
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, radius * 1.3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      ctx.restore();
      
      // Draw labels if enabled
      if (state.showLabels && radius > 2) {
        ctx.fillStyle = 'rgba(220, 240, 255, 0.9)';
        ctx.font = `${Math.max(10, radius * 0.5)}px Inter, Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(obj.name, pos.x, pos.y + radius + 15);
      }
    }

    function drawJupiterBands(pos, radius) {
      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      
      // Draw cloud bands
      const bandColors = ['#D8CA9D', '#C9B87D', '#B89E5A', '#9C7E45'];
      const bandCount = 6;
      
      for (let i = 0; i < bandCount; i++) {
        const bandHeight = radius * 0.15;
        const bandY = pos.y - radius + (i / bandCount) * radius * 2;
        
        ctx.fillStyle = bandColors[i % bandColors.length];
        ctx.fillRect(pos.x - radius, bandY, radius * 2, bandHeight);
      }
      
      // Draw Great Red Spot
      if (radius > 10) {
        ctx.fillStyle = '#B85C5C';
        ctx.beginPath();
        ctx.ellipse(
          pos.x - radius * 0.4, 
          pos.y - radius * 0.2, 
          radius * 0.3, 
          radius * 0.15, 
          0, 0, Math.PI * 2
        );
        ctx.fill();
      }
      
      ctx.restore();
    }

    function drawSaturnRings(pos, radius, t) {
      ctx.save();
      
      // Draw rings
      const ringWidth = radius * 1.8;
      const ringHeight = radius * 0.3;
      
      // Rotate rings over time
      ctx.translate(pos.x, pos.y);
      ctx.rotate((t / 20000) % (Math.PI * 2));
      
      const ringGrd = ctx.createLinearGradient(-ringWidth, 0, ringWidth, 0);
      ringGrd.addColorStop(0, 'rgba(210, 190, 150, 0.1)');
      ringGrd.addColorStop(0.3, 'rgba(230, 210, 170, 0.3)');
      ringGrd.addColorStop(0.5, 'rgba(240, 220, 180, 0.4)');
      ringGrd.addColorStop(0.7, 'rgba(230, 210, 170, 0.3)');
      ringGrd.addColorStop(1, 'rgba(210, 190, 150, 0.1)');
      
      ctx.fillStyle = ringGrd;
      ctx.beginPath();
      ctx.ellipse(0, 0, ringWidth, ringHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Add Cassini Division
      ctx.fillStyle = 'rgba(10, 14, 42, 0.5)';
      ctx.fillRect(-ringWidth * 0.7, -ringHeight * 0.1, ringWidth * 0.05, ringHeight * 0.2);
      
      ctx.restore();
    }

    function drawEarthDetails(pos, radius, t) {
      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      
      // Draw clouds
      for (let i = 0; i < 5; i++) {
        const angle = (t / 5000 + i * 0.4) % (Math.PI * 2);
        const cloudX = pos.x + Math.cos(angle) * radius * 0.7;
        const cloudY = pos.y + Math.sin(angle) * radius * 0.7;
        const cloudR = radius * 0.15;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(cloudX, cloudY, cloudR, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw land masses (simplified)
      ctx.fillStyle = 'rgba(80, 120, 60, 0.4)';
      ctx.beginPath();
      ctx.arc(pos.x - radius * 0.3, pos.y - radius * 0.2, radius * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(pos.x + radius * 0.4, pos.y + radius * 0.3, radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    function drawMarsDetails(pos, radius) {
      ctx.save();
      ctx.globalCompositeOperation = 'overlay';
      
      // Draw Martian features (simplified)
      ctx.fillStyle = 'rgba(140, 70, 60, 0.5)';
      ctx.beginPath();
      ctx.arc(pos.x - radius * 0.4, pos.y - radius * 0.3, radius * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(pos.x + radius * 0.3, pos.y + radius * 0.4, radius * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw polar ice caps
      ctx.fillStyle = 'rgba(220, 240, 255, 0.7)';
      ctx.beginPath();
      ctx.arc(pos.x, pos.y - radius * 0.7, radius * 0.2, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(pos.x, pos.y + radius * 0.7, radius * 0.15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    // Utility functions
    function hexWithAlpha(hex, a) {
      const c = hex.replace('#', '');
      const r = parseInt(c.substring(0, 2), 16);
      const g = parseInt(c.substring(2, 4), 16);
      const b = parseInt(c.substring(4, 6), 16);
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    
    function shadeColor(hex, percent) {
      // percent between -1 and 1
      const c = hex.replace('#', '');
      const r = Math.max(0, Math.min(255, parseInt(c.substring(0, 2), 16) * (1 + percent)));
      const g = Math.max(0, Math.min(255, parseInt(c.substring(2, 4), 16) * (1 + percent)));
      const b = Math.max(0, Math.min(255, parseInt(c.substring(4, 6), 16) * (1 + percent)));
      return `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
    }
    
    function lightenColor(hex, percent) {
      return shadeColor(hex, Math.abs(percent));
    }

    // Start the animation
    requestAnimationFrame(frame);

    // Expose some state for console tweaking
    window.UNIVERSE = { 
      solarSystem, 
      nebulae, 
      camera, 
      state,
      regenerateStars: generateRealisticStars 
    };
  })();
  </script>
</body>
</html>